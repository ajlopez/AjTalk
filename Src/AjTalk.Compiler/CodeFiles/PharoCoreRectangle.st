'From Pharo1.3 of 16 June 2011 [Latest update: #13315] on 29 October 2011 at 4:48:34 pm'!Object subclass: #Rectangle	instanceVariableNames: 'origin corner'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Rectangle commentStamp: 'StephaneDucasse 8/8/2010 18:13' prior: 0!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:	from rectangle origin (the point having smallest coordinates in reference frame),	to rectangle corner (the point having largest coordinates in reference frame).Note 3: Screen coordinates conventions are:	x is horizontal axis, zero at left border, oriented toward right;	y is vertical axis, zero at top border, oriented toward bottom.This corresponds to the latin convention for writing text from left to right and top to bottom.Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.Instance variables:	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)!!Rectangle methodsFor: 'accessing' stamp: 'acg 2/23/2000 00:52'!aboveCenter	"Answer the point slightly above the center of the receiver."	^self topLeft + self bottomRight // (2@3)! !!Rectangle methodsFor: 'accessing' stamp: 'lr 7/4/2009 10:42'!area	"Answer the receiver's area, the product of width and height."	| w |	(w := self width) <= 0 ifTrue: [ ^ 0 ].	^ w * self height max: 0! !!Rectangle methodsFor: 'accessing'!bottom	"Answer the position of the receiver's bottom horizontal line."	^corner y! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!bottom: aNumber	^origin corner: corner x @ aNumber! !!Rectangle methodsFor: 'accessing'!bottomCenter	"Answer the point at the center of the bottom horizontal line of the 	receiver."	^self center x @ self bottom! !!Rectangle methodsFor: 'accessing'!bottomLeft	"Answer the point at the left edge of the bottom horizontal line of the 	receiver."	^origin x @ corner y! !!Rectangle methodsFor: 'accessing'!bottomRight	"Answer the point at the right edge of the bottom horizontal line of the 	receiver."	^corner! !!Rectangle methodsFor: 'accessing'!boundingBox	^ self! !!Rectangle methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^self topLeft + self bottomRight // 2! !!Rectangle methodsFor: 'accessing'!corner	"Answer the point at the bottom right corner of the receiver."	^corner! !!Rectangle methodsFor: 'accessing'!corners	"Return an array of corner points in the order of a quadrilateral spec for WarpBlt."	^ Array		with: self topLeft		with: self bottomLeft		with: self bottomRight		with: self topRight! !!Rectangle methodsFor: 'accessing' stamp: 'StephaneDucasse 4/4/2010 15:00'!extent	"Answer a point with the receiver's width @ the receiver's height."	^corner - origin! !!Rectangle methodsFor: 'accessing'!height	"Answer the height of the receiver."	^corner y - origin y! !!Rectangle methodsFor: 'accessing' stamp: 'lr 7/4/2009 10:42'!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 := self topLeft corner: self bottomRight - (1 @ 1).	^ Array 		with: r1 topLeft		with: r1 bottomLeft		with: r1 bottomRight		with: r1 topRight! !!Rectangle methodsFor: 'accessing'!left	"Answer the position of the receiver's left vertical line."	^origin x! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:16'!left: aNumber	^aNumber @ origin y corner: corner! !!Rectangle methodsFor: 'accessing'!leftCenter	"Answer the point at the center of the receiver's left vertical line."	^self left @ self center y! !!Rectangle methodsFor: 'accessing'!origin	"Answer the point at the top left corner of the receiver."	^origin! !!Rectangle methodsFor: 'accessing' stamp: 'gvc 6/7/2006 10:44'!pointAtSideOrCorner: loc	"Answer the point represented by the given location."		^ self		perform: (#(topLeft topCenter topRight rightCenter					bottomRight bottomCenter bottomLeft leftCenter)						at: (#(topLeft top topRight right					bottomRight bottom bottomLeft left) indexOf: loc))	! !!Rectangle methodsFor: 'accessing'!right	"Answer the position of the receiver's right vertical line."	^corner x! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!right: aNumber	^origin corner: aNumber @ corner y! !!Rectangle methodsFor: 'accessing'!rightCenter	"Answer the point at the center of the receiver's right vertical line."	^self right @ self center y! !!Rectangle methodsFor: 'accessing'!top	"Answer the position of the receiver's top horizontal line."	^origin y! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!top: aNumber	^origin x @ aNumber corner: corner! !!Rectangle methodsFor: 'accessing'!topCenter	"Answer the point at the center of the receiver's top horizontal line."	^self center x @ self top! !!Rectangle methodsFor: 'accessing'!topLeft	"Answer the point at the top left corner of the receiver's top horizontal line."	^origin! !!Rectangle methodsFor: 'accessing'!topRight	"Answer the point at the top right corner of the receiver's top horizontal 	line."	^corner x @ origin y! !!Rectangle methodsFor: 'accessing'!width	"Answer the width of the receiver."	^corner x - origin x! !!Rectangle methodsFor: 'comparing'!= aRectangle 	"Answer true if the receiver's species, origin and corner match aRectangle's."	self species = aRectangle species		ifTrue: [^origin = aRectangle origin and: [corner = aRectangle corner]]		ifFalse: [^false]! !!Rectangle methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^origin hash bitXor: corner hash! !!Rectangle methodsFor: 'fmp' stamp: 'lr 7/4/2009 10:42'!deltaToEnsureInOrCentered: r extra: aNumber 	| dX dY halfXDiff halfYDiff |	dX := dY := 0.	halfXDiff := ((r width - self width) * aNumber) truncated.	halfYDiff := ((r height - self height) * aNumber) truncated.	self left < r left 		ifTrue: [ dX := self left - r left - halfXDiff ]		ifFalse: 			[ self right > r right ifTrue: [ dX := self right - r right + halfXDiff ] ].	self top < r top 		ifTrue: [ dY := self top - r top - halfYDiff ]		ifFalse: 			[ self bottom > r bottom ifTrue: [ dY := self bottom - r bottom + halfYDiff ] ].	^ dX @ dY! !!Rectangle methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	origin printOn: aStream.	aStream nextPutAll: ' corner: '.	corner printOn: aStream! !!Rectangle methodsFor: 'printing' stamp: 'nice 11/1/2009 20:27'!storeOn: aStream 	"printed form is good for storing too"		aStream nextPut: $(.	self printOn: aStream.	aStream nextPut: $).! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:04'!allAreasOutsideList: aCollection do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	^self allAreasOutsideList: aCollection startingAt: 1 do: aBlock! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!allAreasOutsideList: aCollection startingAt: startIndex do: aBlock 	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	| yOrigin yCorner aRectangle index rr |	index := startIndex.	"Find the next intersecting rectangle from aCollection"		[ index <= aCollection size ifFalse: [ ^ aBlock value: self ].	aRectangle := aCollection at: index.	origin <= aRectangle corner and: [ aRectangle origin <= corner ] ] whileFalse: [ index := index + 1 ].	"aRectangle is intersecting; process it"	aRectangle origin y > origin y 		ifTrue: 			[ rr := origin corner: corner x @ (yOrigin := aRectangle origin y).			rr 				allAreasOutsideList: aCollection				startingAt: index + 1				do: aBlock ]		ifFalse: [ yOrigin := origin y ].	aRectangle corner y < corner y 		ifTrue: 			[ rr := origin x @ (yCorner := aRectangle corner y) corner: corner.			rr 				allAreasOutsideList: aCollection				startingAt: index + 1				do: aBlock ]		ifFalse: [ yCorner := corner y ].	aRectangle origin x > origin x ifTrue: 		[ rr := origin x @ yOrigin corner: aRectangle origin x @ yCorner.		rr 			allAreasOutsideList: aCollection			startingAt: index + 1			do: aBlock ].	aRectangle corner x < corner x ifTrue: 		[ rr := aRectangle corner x @ yOrigin corner: corner x @ yCorner.		rr 			allAreasOutsideList: aCollection			startingAt: index + 1			do: aBlock ]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!amountToTranslateWithin: aRectangle 	"Answer a Point, delta, such that self + delta is forced within aRectangle."	"Altered so as to prefer to keep self topLeft inside when all of self	cannot be made to fit 7/27/96 di"	| dx dy |	dx := 0.	dy := 0.	self right > aRectangle right ifTrue: [ dx := aRectangle right - self right ].	self bottom > aRectangle bottom ifTrue: [ dy := aRectangle bottom - self bottom ].	self left + dx < aRectangle left ifTrue: [ dx := aRectangle left - self left ].	self top + dy < aRectangle top ifTrue: [ dy := aRectangle top - self top ].	^ dx @ dy! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!areasOutside: aRectangle 	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	"Make sure the intersection is non-empty"	| areas yOrigin yCorner |	(self intersects: aRectangle) ifFalse: [ ^ Array with: self ].	areas := OrderedCollection new.	aRectangle origin y > origin y 		ifTrue: 			[ areas addLast: (origin corner: corner x @ (yOrigin := aRectangle origin y)) ]		ifFalse: [ yOrigin := origin y ].	aRectangle corner y < corner y 		ifTrue: 			[ areas addLast: (origin x @ (yCorner := aRectangle corner y) corner: corner) ]		ifFalse: [ yCorner := corner y ].	aRectangle origin x > origin x ifTrue: 		[ areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner) ].	aRectangle corner x < corner x ifTrue: 		[ areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner) ].	^ areas! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions'!encompass: aPoint 	"Answer a Rectangle that contains both the receiver and aPoint.  5/30/96 sw"	^ Rectangle 		origin: (origin min: aPoint)		corner: (corner max:  aPoint)! !!Rectangle methodsFor: 'rectangle functions' stamp: 'md 10/4/2005 14:42'!expandBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isRectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'md 10/4/2005 14:42'!extendBy: delta 	"Answer a Rectangle with the same origin as the receiver, but whose corner is offset by delta. delta is a 	Rectangle, Point, or scalar."	(delta isRectangle)		ifTrue: [^Rectangle 					origin: origin					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!forPoint: aPoint closestSideDistLen: sideDistLenBlock 	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side := self sideNearestTo: aPoint.	side == #right ifTrue: 		[ ^ sideDistLenBlock 			value: side			value: (self right - aPoint x) abs			value: ((aPoint y 					between: self top					and: self bottom) 					ifTrue: [ self height ]					ifFalse: [ 0 ]) ].	side == #left ifTrue: 		[ ^ sideDistLenBlock 			value: side			value: (self left - aPoint x) abs			value: ((aPoint y 					between: self top					and: self bottom) 					ifTrue: [ self height ]					ifFalse: [ 0 ]) ].	side == #bottom ifTrue: 		[ ^ sideDistLenBlock 			value: side			value: (self bottom - aPoint y) abs			value: ((aPoint x 					between: self left					and: self right) 					ifTrue: [ self width ]					ifFalse: [ 0 ]) ].	side == #top ifTrue: 		[ ^ sideDistLenBlock 			value: side			value: (self top - aPoint y) abs			value: ((aPoint x 					between: self left					and: self right) 					ifTrue: [ self width ]					ifFalse: [ 0 ]) ]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'md 10/2/2005 21:51'!insetBy: delta 	"Answer a Rectangle that is inset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."		(delta isRectangle)		ifTrue: [^Rectangle 					origin: origin + delta origin 					corner: corner - delta corner]		ifFalse: [^Rectangle 					origin: origin + delta 					corner: corner - delta]! !!Rectangle methodsFor: 'rectangle functions'!insetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint 	"Answer a Rectangle that is inset from the receiver by a given amount in 	the origin and corner."	^Rectangle		origin: origin + originDeltaPoint		corner: corner - cornerDeltaPoint! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!intersect: aRectangle 	"Answer a Rectangle that is the area in which the receiver overlaps with 	aRectangle. Optimized for speed; old code read:		^Rectangle 			origin: (origin max: aRectangle origin)			corner: (corner min: aRectangle corner)	"	| aPoint left right top bottom |	aPoint := aRectangle origin.	aPoint x > origin x 		ifTrue: [ left := aPoint x ]		ifFalse: [ left := origin x ].	aPoint y > origin y 		ifTrue: [ top := aPoint y ]		ifFalse: [ top := origin y ].	aPoint := aRectangle corner.	aPoint x < corner x 		ifTrue: [ right := aPoint x ]		ifFalse: [ right := corner x ].	aPoint y < corner y 		ifTrue: [ bottom := aPoint y ]		ifFalse: [ bottom := corner y ].	^ Rectangle 		origin: left @ top		corner: right @ bottom! !!Rectangle methodsFor: 'rectangle functions'!merge: aRectangle 	"Answer a Rectangle that contains both the receiver and aRectangle."	^Rectangle 		origin: (origin min: aRectangle origin)		corner: (corner max: aRectangle corner)! !!Rectangle methodsFor: 'rectangle functions' stamp: 'md 10/4/2005 14:41'!outsetBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isRectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!pointNearestTo: aPoint 	"Return the point on my border closest to aPoint"	| side |	(self containsPoint: aPoint) 		ifTrue: 			[ side := self sideNearestTo: aPoint.			side == #right ifTrue: [ ^ self right @ aPoint y ].			side == #left ifTrue: [ ^ self left @ aPoint y ].			side == #bottom ifTrue: [ ^ aPoint x @ self bottom ].			side == #top ifTrue: [ ^ aPoint x @ self top ] ]		ifFalse: [ ^ aPoint adhereTo: self ]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'JuanVuletich 10/11/2010 19:51'!quickMerge: aRectangle 	"Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."	| useRcvr rOrigin rCorner minX maxX minY maxY |		aRectangle ifNil: [ ^self ].		useRcvr := true.	rOrigin := aRectangle topLeft.	rCorner := aRectangle bottomRight.	minX := rOrigin x < origin x 		ifTrue: 			[ useRcvr := false.			rOrigin x ]		ifFalse: [ origin x ].	maxX := rCorner x > corner x 		ifTrue: 			[ useRcvr := false.			rCorner x ]		ifFalse: [ corner x ].	minY := rOrigin y < origin y 		ifTrue: 			[ useRcvr := false.			rOrigin y ]		ifFalse: [ origin y ].	maxY := rCorner y > corner y 		ifTrue: 			[ useRcvr := false.			rCorner y ]		ifFalse: [ corner y ].	useRcvr 		ifTrue: [ ^ self ]		ifFalse: 			[ ^ Rectangle 				origin: minX @ minY				corner: maxX @ maxY ]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/20/97 23:01'!rectanglesAt: y height: ht	(y+ht) > self bottom ifTrue: [^ Array new].	^ Array with: (origin x @ y corner: corner x @ (y+ht))! !!Rectangle methodsFor: 'rectangle functions' stamp: 'lr 7/4/2009 10:42'!sideNearestTo: aPoint 	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft := aPoint x - self left.	distToRight := self right - aPoint x.	distToTop := aPoint y - self top.	distToBottom := self bottom - aPoint y.	closest := distToLeft.	side := #left.	distToRight < closest ifTrue: 		[ closest := distToRight.		side := #right ].	distToTop < closest ifTrue: 		[ closest := distToTop.		side := #top ].	distToBottom < closest ifTrue: 		[ closest := distToBottom.		side := #bottom ].	^ side	" | r | r := Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!Rectangle methodsFor: 'rectangle functions'!translatedToBeWithin: aRectangle	"Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"	^ self translateBy: (self amountToTranslateWithin: aRectangle)! !!Rectangle methodsFor: 'rectangle functions'!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y! !!Rectangle methodsFor: 'rectangle functions'!withHeight: height 	"Return a copy of me with a different height"	^ origin corner: corner x @ (origin y + height)! !!Rectangle methodsFor: 'rectangle functions'!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 9/8/1999 21:25'!withSideOrCorner: side setToPoint: newPoint	"Return a copy with side set to newPoint"	^ self withSideOrCorner: side setToPoint: newPoint minExtent: 0@0! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:16'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent	"Return a copy with side set to newPoint"	^self withSideOrCorner: side setToPoint: newPoint minExtent: minExtent		limit: ((#(left top) includes: side) ifTrue: [SmallInteger minVal] ifFalse: [SmallInteger maxVal])! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:07'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit	"Return a copy with side set to newPoint"	side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)].	side = #bottom ifTrue: [^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)].	side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)].	side = #right ifTrue: [^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)].	side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].	side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].	side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].	side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !!Rectangle methodsFor: 'rectangle functions'!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withWidth: width 	"Return a copy of me with a different width"	^ origin corner: (origin x + width) @ corner y! !!Rectangle methodsFor: 'self evaluating' stamp: 'sd 7/31/2005 21:49'!isSelfEvaluating	^ self class == Rectangle! !!Rectangle methodsFor: 'testing'!containsPoint: aPoint 	"Answer whether aPoint is within the receiver."	^origin <= aPoint and: [aPoint < corner]! !!Rectangle methodsFor: 'testing'!containsRect: aRect	"Answer whether aRect is within the receiver (OK to coincide)."	^ aRect origin >= origin and: [aRect corner <= corner]! !!Rectangle methodsFor: 'testing'!hasPositiveExtent	^ (corner x > origin x) and: [corner y > origin y]! !!Rectangle methodsFor: 'testing' stamp: 'lr 7/4/2009 10:42'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x ifTrue: [ ^ false ].	rCorner y <= origin y ifTrue: [ ^ false ].	rOrigin x >= corner x ifTrue: [ ^ false ].	rOrigin y >= corner y ifTrue: [ ^ false ].	^ true! !!Rectangle methodsFor: 'testing' stamp: 'md 10/2/2005 21:51'!isRectangle	^true! !!Rectangle methodsFor: 'testing'!isTall	^ self height > self width! !!Rectangle methodsFor: 'testing'!isWide	^ self width > self height! !!Rectangle methodsFor: 'testing' stamp: 'ar 10/29/2000 19:03'!isZero	^origin isZero and:[corner isZero]! !!Rectangle methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Answer a Rectangle that is a translated by aPoint2 - aPoint1."	^self translateBy: aPoint2 - aPoint1! !!Rectangle methodsFor: 'transforming'!centeredBeneath: aRectangle	 "Move the reciever so that its top center point coincides with the bottom center point of aRectangle.  5/20/96 sw:"	^ self align: self topCenter with: aRectangle bottomCenter! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 16:24'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	^ (origin flipBy: direction centerAt: aPoint)		rect: (corner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming' stamp: 'gvc 4/24/2007 12:51'!interpolateTo: end at: amountDone	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."	^(self origin interpolateTo: end origin at: amountDone)		corner: (self corner interpolateTo: end corner at: amountDone)! !!Rectangle methodsFor: 'transforming' stamp: 'lr 7/4/2009 10:42'!newRectButtonPressedDo: newRectBlock 	"Track the outline of a new rectangle until mouse button 	changes. newFrameBlock produces each new rectangle from the 	previous. Only tracks while mouse is down."	| rect newRect buttonNow delay |	delay := Delay forMilliseconds: 10.	buttonNow := Sensor anyButtonPressed.	rect := self.	Display 		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	[ buttonNow ] whileTrue: 		[ delay wait.		[ Sensor nextEvent isNil ] whileFalse.		buttonNow := Sensor anyButtonPressed.		newRect := newRectBlock value: rect.		newRect = rect ifFalse: 			[ Display 				border: rect				width: 2				rule: Form reverse				fillColor: Color gray.			Display 				border: newRect				width: 2				rule: Form reverse				fillColor: Color gray.			rect := newRect ] ].	Display 		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	World activeHand		newMouseFocus: nil;		showTemporaryCursor: nil.	^ rect! !!Rectangle methodsFor: 'transforming' stamp: 'lr 7/4/2009 10:42'!newRectFrom: newRectBlock 	"Track the outline of a new rectangle until mouse button changes.	newFrameBlock produces each new rectangle from the previous"	| rect newRect buttonStart buttonNow delay |	delay := Delay forMilliseconds: 10.	buttonStart := buttonNow := Sensor anyButtonPressed.	rect := self.	Display 		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	[ buttonNow == buttonStart ] whileTrue: 		[ delay wait.		[ Sensor nextEvent isNil ] whileFalse.		buttonNow := Sensor anyButtonPressed.		newRect := newRectBlock value: rect.		newRect = rect ifFalse: 			[ Display 				border: rect				width: 2				rule: Form reverse				fillColor: Color gray.			Display 				border: newRect				width: 2				rule: Form reverse				fillColor: Color gray.			rect := newRect ] ].	Display 		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	World activeHand		newMouseFocus: nil;		showTemporaryCursor: nil.	^ rect! !!Rectangle methodsFor: 'transforming' stamp: 'gvc 6/25/2007 14:00'!quickMergePoint: aPoint	"Answer the receiver if it encloses the given point or the expansion of the	receiver to do so if it doesn't. "	| useRcvr minX maxX minY maxY |	useRcvr := true.	minX := aPoint x < origin x ifTrue: [useRcvr := false. aPoint x] ifFalse: [origin x].	maxX := aPoint x >= corner x ifTrue: [useRcvr := false. aPoint x + 1] ifFalse: [corner x].	minY := aPoint y < origin y ifTrue: [useRcvr := false. aPoint y] ifFalse: [origin y].	maxY := aPoint y >= corner y ifTrue: [useRcvr := false. aPoint y + 1] ifFalse: [corner y].	^useRcvr		ifTrue: [self]		ifFalse: [minX @ minY corner: maxX @ maxY]! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 15:11'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	^ (origin rotateBy: direction centerAt: aPoint)		rect: (corner rotateBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming'!scaleBy: scale 	"Answer a Rectangle scaled by scale, a Point or a scalar."	^Rectangle origin: origin * scale corner: corner * scale! !!Rectangle methodsFor: 'transforming'!scaleFrom: rect1 to: rect2	"Produce a rectangle stretched according to the stretch from rect1 to rect2"	^ (origin scaleFrom: rect1 to: rect2)		corner: (corner scaleFrom: rect1 to: rect2)! !!Rectangle methodsFor: 'transforming' stamp: 'gvc 6/13/2006 14:08'!scaledAndCenteredIn: aRect	"Answer a new rectangle that fits into aRectangle and is centered	but with the same aspect ratio as the receiver."		^self width / aRect width > (self height / aRect height)		ifTrue: [aRect left @ (aRect leftCenter y - (self height * (aRect width / self width) / 2))					corner: aRect right @ (aRect rightCenter y + (self height * (aRect width / self width) / 2))]		ifFalse: [aRect topCenter x - (self width * (aRect height / self height) / 2) @ aRect top					corner: (aRect topCenter x + (self width * (aRect height / self height) / 2)) @ aRect bottom]! !!Rectangle methodsFor: 'transforming' stamp: 'sw 5/21/96'!squishedWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin.  "	^ origin corner: (corner min: aRectangle bottomRight)"(50 @ 50 corner: 160 @ 100) squishedWithin:  (20 @ 10 corner: 90 @ 85)"! !!Rectangle methodsFor: 'transforming'!translateBy: factor 	"Answer a Rectangle translated by factor, a Point or a scalar."	^Rectangle origin: origin + factor corner: corner + factor! !!Rectangle methodsFor: 'transforming' stamp: 'nk 7/5/2003 08:31'!translatedAndSquishedToBeWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by		- translating it to be within aRectangle if necessary, then		- reducing its size, if necessary"	^ (self translatedToBeWithin: aRectangle) squishedWithin: aRectangle! !!Rectangle methodsFor: 'truncation and round off'!rounded	"Answer a Rectangle whose origin and corner are rounded."	^Rectangle origin: origin rounded corner: corner rounded! !!Rectangle methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Rectangle whose origin and corner are truncated to grid x and grid y."	^Rectangle origin: (origin truncateTo: grid)				corner: (corner truncateTo: grid)! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'StephaneDucasse 5/27/2010 22:10'!ceiling	"Answer the integer rectange to the bottom right of receiver.	Return reciever if it already and integerRectange."	self isIntegerRectangle ifTrue: [ ^ self ].	^origin ceiling corner: corner ceiling! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'wiz 2/12/2006 01:37'!compressTo: grid	"Answer a Rectangle whose origin and corner are rounded to grid x and grid y.	Rounding is done by upper value on origin and lower value on corner so that	rounded rectangle is inside self."	^Rectangle origin: (origin roundUpTo: grid)				corner: (corner roundDownTo: grid)! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'wiz 2/12/2006 01:37'!compressed	"Answer a Rectangle whose origin and corner are rounded to integers.	Rounding is done by upper value on origin and lower value on corner so that	rounded rectangle is inside self."	^Rectangle origin: origin ceiling corner: corner floor! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:51'!expandTo: grid	"Answer a Rectangle whose origin and corner are rounded to grid x and grid y.	Rounding is done by upper value on origin and lower value on corner so that	self is inside rounded rectangle."	^Rectangle origin: (origin roundDownTo: grid)				corner: (corner roundUpTo: grid)! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:52'!expanded	"Answer a Rectangle whose origin and corner are rounded to integers.	Rounding is done by upper value on origin and lower value on corner so that	self is inside rounded rectangle."	^Rectangle origin: origin floor corner: corner ceiling! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'wiz 2/12/2006 15:56'!floor"Answer the integer rectange to the topleft of receiver.Return reciever if it already and integerRectange."self isIntegerRectangle ifTrue: [ ^ self ] .^origin floor corner: corner floor! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'wiz 1/11/2006 18:39'!isIntegerRectangle"Answer true if all component of receiver are integral."^origin isIntegerPoint and: [ corner isIntegerPoint ]! !!Rectangle methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:53'!roundTo: grid	"Answer a Rectangle whose origin and corner are rounded to grid x and grid y."	^Rectangle origin: (origin roundTo: grid)				corner: (corner roundTo: grid)! !!Rectangle methodsFor: 'private' stamp: 'lr 7/4/2009 10:42'!setOrigin: topLeft corner: bottomRight 	origin := topLeft.	corner := bottomRight! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Rectangle class	instanceVariableNames: ''!!Rectangle class methodsFor: '*Graphics-Display Objects'!fromUser	"Answer an instance of me that is determined by having the user 	designate the top left and bottom right corners. The gridding for user 	selection is 1@1."	^self fromUser: 1 @ 1! !!Rectangle class methodsFor: '*Graphics-Display Objects' stamp: 'lr 7/4/2009 10:42'!fromUser: gridPoint 	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners. 	The cursor reamins linked with the sensor, but	the outline is kept gridded."	| originRect |	originRect := Cursor origin showWhile: 		[ ((Sensor cursorPoint grid: gridPoint) extent: 0 @ 0) newRectFrom: [ :f | (Sensor cursorPoint grid: gridPoint) extent: 0 @ 0 ] ].	^ Cursor corner showWhile: 		[ originRect newRectFrom: [ :f | f origin corner: (Sensor cursorPoint grid: gridPoint) ] ]! !!Rectangle class methodsFor: '*Graphics-Display Objects'!originFromUser: extentPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is 1@1."	^self originFromUser: extentPoint grid: 1 @ 1! !!Rectangle class methodsFor: '*Graphics-Display Objects'!originFromUser: extentPoint grid: gridPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is scaleFactor. Assumes that 	the sender has determined an extent that is a proper multiple of 	scaleFactor."	^ Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: extentPoint) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: extentPoint]].! !!Rectangle class methodsFor: 'instance creation' stamp: 'tk 3/9/97'!center: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^self origin: centerPoint - (extentPoint//2) extent: extentPoint! !!Rectangle class methodsFor: 'instance creation' stamp: 'lr 7/4/2009 10:42'!encompassing: listOfPoints 	"A number of callers of encompass: should use this method."	| topLeft bottomRight |	topLeft := bottomRight := nil.	listOfPoints do: 		[ :p | 		topLeft == nil 			ifTrue: [ topLeft := bottomRight := p ]			ifFalse: 				[ topLeft := topLeft min: p.				bottomRight := bottomRight max: p ] ].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:02'!left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 	"Answer an instance of me whose left, right, top, and bottom coordinates 	are determined by the arguments."	^ self basicNew setOrigin: leftNumber @ topNumber corner: rightNumber @ bottomNumber! !!Rectangle class methodsFor: 'instance creation' stamp: 'lr 7/4/2009 10:42'!merging: listOfRects 	"A number of callers of merge: should use this method."	| minX minY maxX maxY |	listOfRects do: 		[ :r | 		minX 			ifNil: 				[ minX := r topLeft x.				minY := r topLeft y.				maxX := r bottomRight x.				maxY := r bottomRight y ]			ifNotNil: 				[ minX := minX min: r topLeft x.				minY := minY min: r topLeft y.				maxX := maxX max: r bottomRight x.				maxY := maxY max: r bottomRight y ] ].	^ minX @ minY corner: maxX @ maxY! !!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:04'!origin: originPoint corner: cornerPoint 	"Answer an instance of me whose corners (top left and bottom right) are 	determined by the arguments."	^self basicNew setOrigin: originPoint corner: cornerPoint! !!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:03'!origin: originPoint extent: extentPoint 	"Answer an instance of me whose top left corner is originPoint and width 	by height is extentPoint."	^self basicNew setOrigin: originPoint corner: originPoint + extentPoint! !
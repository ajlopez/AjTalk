'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 19 September 2010 at 6:57:05 pm'!ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields'	poolDictionaries: ''	category: 'Kernel-Objects'!!Object commentStamp: '<historical>' prior: 0!Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.	EventsFields			an IdentityDictionary that maps each object to its dependents.		Registers a message send (consisting of a selector and a receiver object)		which should be performed when anEventSymbol is triggered by the receiver.		Part of a new event notification framework which could eventually replace		the existing changed/update mechanism.  It is intended to be compatible		with Dolphin Smalltalk and VSE as much as possible.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.!!Object methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:18'!addInstanceVarNamed: aName withValue: aValue	"Add an instance variable named aName and give it value aValue"	self class addInstVarName: aName asString.	self instVarAt: self class instSize put: aValue! !!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!at: index modify: aBlock	"Replace the element of the collection with itself transformed by the block"	^ self at: index put: (aBlock value: (self at: index))! !!Object methodsFor: 'accessing' stamp: 'yo 6/29/2004 13:08'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'yo 9/20/2004 10:22'!basicAddInstanceVarNamed: aName withValue: aValue	"Add an instance variable named aName and give it value aValue"	self class addInstVarName: aName asString.	self instVarAt: self class instSize put: aValue! !!Object methodsFor: 'accessing'!basicAt: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !